#!/usr/bin/env node
import { spawnSync } from 'node:child_process';
import { copyFileSync, existsSync, mkdirSync, renameSync, rmSync, writeFileSync } from 'node:fs';
import path from 'node:path';

const repoRoot = process.cwd();

function fail(message) {
  console.error(message);
  process.exit(1);
}

function printUsage() {
  console.log('사용법: node scripts/android-build.mjs <appName> <apk|aab>');
  console.log('예) npm run alimi:apk');
  console.log('예) npm run alimi:aab');
}

function isWindows() {
  return process.platform === 'win32';
}

function run(command, args, options = {}) {
  const cwdLabel = options.cwd ? ` (cwd: ${options.cwd})` : '';
  console.log(`$ ${command} ${args.join(' ')}${cwdLabel}`);
  const result = spawnSync(command, args, {
    stdio: 'inherit',
    shell: false,
    ...options
  });
  if (result.error) {
    console.error(`명령 실행 실패: ${command}`);
    console.error(result.error);
    process.exit(1);
  }
  if (result.status !== 0) {
    console.error(`명령 종료 코드: ${result.status}`);
    process.exit(result.status ?? 1);
  }
}

function runViaCmd(commandLineArgs, options = {}) {
  const comspec = process.env.ComSpec || 'cmd.exe';
  run(comspec, ['/d', '/s', '/c', ...commandLineArgs], options);
}

function runNpx(args, options = {}) {
  if (isWindows()) {
    runViaCmd(['npx', ...args], options);
    return;
  }
  run('npx', args, options);
}

function getTempEntryContent(appName) {
  // Gradle(react-native-gradle-plugin)에서 Expo CLI `export:embed`를 실행할 때
  // 모노레포 루트 기준으로 `--entry-file index.ts`가 전달되는 케이스가 있어,
  // 루트에 임시 entry 파일을 생성해 앱의 실제 엔트리로 위임한다.
  return `// AUTO-GENERATED by scripts/android-build.mjs (temporary)\n` + `import './apps/${appName}/index';\n`;
}

const [, , appName, target] = process.argv;

if (appName === '-h' || appName === '--help' || target === '-h' || target === '--help') {
  printUsage();
  process.exit(0);
}

if (!appName || !target) {
  printUsage();
  process.exit(1);
}

const appDir = path.join(repoRoot, 'apps', appName);
if (!existsSync(appDir)) fail(`폴더를 찾을 수 없습니다: ${appDir}`);

const appJsonPath = path.join(appDir, 'app.json');
if (!existsSync(appJsonPath)) {
  fail(
    `apps/${appName}/app.json 이 없습니다.\n` +
      `- Expo 앱이 아니라면, 먼저 Expo 프로젝트를 생성/이동해 주세요.\n` +
      `- Expo 앱이라면 app.json(또는 app.config.*)을 추가해 주세요.`
  );
}

const gradleTask = target === 'apk' ? 'assembleRelease' : target === 'aab' ? 'bundleRelease' : null;
if (!gradleTask) fail(`target은 apk 또는 aab만 가능합니다. 입력값: ${target}`);

const env = {
  ...process.env,
  // expo-constants/createExpoConfig가 NODE_ENV를 요구하는 케이스가 있어 기본값을 넣어 둔다.
  NODE_ENV: process.env.NODE_ENV ?? 'production',
  // Expo prebuild를 비대화형으로 진행(터미널이 비대화형일 때도 멈추지 않도록)
  CI: process.env.CI ?? '1'
};

const rootIndexPath = path.join(repoRoot, 'index.ts');
const rootIndexBackupPath = path.join(repoRoot, 'index.ts.android-build.bak');
const hadRootIndex = existsSync(rootIndexPath);

try {
  if (hadRootIndex) renameSync(rootIndexPath, rootIndexBackupPath);
  writeFileSync(rootIndexPath, getTempEntryContent(appName), 'utf8');

  const androidDir = path.join(appDir, 'android');
  const prebuildFlag = process.env.BORINE_PREBUILD; // '1' | '0' | undefined
  const shouldPrebuild =
    prebuildFlag === '1' ? true : prebuildFlag === '0' ? false : !existsSync(androidDir);
  const shouldCleanPrebuild =
    process.env.BORINE_PREBUILD_CLEAN === '1' ||
    (!existsSync(androidDir) && process.env.BORINE_PREBUILD_CLEAN !== '0');

  if (shouldPrebuild) {
    console.log(
      `[1/2] Prebuild (apps/${appName})` + (shouldCleanPrebuild ? ' [clean]' : ' [reuse existing android]')
    );
    const prebuildArgs = ['expo', 'prebuild', '--platform', 'android', '--no-install'];
    if (shouldCleanPrebuild) prebuildArgs.push('--clean');
    runNpx(prebuildArgs, { cwd: appDir, env });
  } else {
    console.log(`[1/2] Prebuild (apps/${appName}) [skipped]`);
  }

  if (!existsSync(androidDir)) {
    fail(
      `android 폴더가 없습니다: ${androidDir}\n` +
        `- prebuild 로그에 오류가 없는지 확인해 주세요.\n` +
        `- Windows에서 경로/권한/백신 영향으로 생성이 막힐 수 있습니다.`
    );
  }

  console.log(`[2/2] Gradle ${gradleTask} (apps/${appName}/android)`);
  if (isWindows()) {
    runViaCmd(['gradlew.bat', gradleTask], { cwd: androidDir, env });
  } else {
    run('./gradlew', [gradleTask], { cwd: androidDir, env });
  }

  if (target === 'apk') {
    const apkPath = path.join(androidDir, 'app', 'build', 'outputs', 'apk', 'release', 'app-release.apk');
    console.log(`완료: ${apkPath}`);
    const distDir = path.join(repoRoot, 'dist', 'android', appName);
    mkdirSync(distDir, { recursive: true });
    const distApkPath = path.join(distDir, 'app-release.apk');
    copyFileSync(apkPath, distApkPath);
    console.log(`복사: ${distApkPath}`);
  } else {
    const aabPath = path.join(androidDir, 'app', 'build', 'outputs', 'bundle', 'release', 'app-release.aab');
    console.log(`완료: ${aabPath}`);
    const distDir = path.join(repoRoot, 'dist', 'android', appName);
    mkdirSync(distDir, { recursive: true });
    const distAabPath = path.join(distDir, 'app-release.aab');
    copyFileSync(aabPath, distAabPath);
    console.log(`복사: ${distAabPath}`);
  }
} finally {
  try {
    if (existsSync(rootIndexPath)) rmSync(rootIndexPath);
  } catch {}
  try {
    if (existsSync(rootIndexBackupPath)) renameSync(rootIndexBackupPath, rootIndexPath);
  } catch {}
}
